#!/usr/bin/python3
#   (c) 2025 Chris Royle
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <https://www.gnu.org/licenses/>.

import sys
import AUNProtocol
import re
import getopt
import threading

def select_server (server):
    my_match = re.search("^\s*(\d{1,3})\.(\d{1,3})\s*$", server)

    if (my_match != None):
        my_net = int(my_match.group(1))
        my_stn = int(my_match.group(2))
    else:
        return None, None

    return my_net, my_stn

def login (my_net, my_stn, username, password):

    if username != "":
        login_string = f'I AM {username} {password}'

        result, error, reply_packet = aun_client.FSOp(my_net, my_stn, 0x00, bytearray(login_string, 'ascii'))
        
        if reply_packet == None:
            aun_client.debug("No reply")
            return False
        elif error != 0:
            print (aun_client.report_FSOp_result(aun_client, result, error, reply_packet))
            return False
        else:
            return True

    return True

def execute_script(aun_client, script, server = "1.254", username = "", password = ""):

    my_net, my_stn = select_server(server)

    if my_net == None:
        return None 

    if login(my_net, my_stn, username, password) == False:
        return None

    with open(script, "r") as h:
        for rline in h:
            line = rline.strip("\n")
            for count in range (0, len(script_params)):
                line = re.sub(rf'%{count+1}', script_params[count], line)
            fs_match = re.search("^FS\s+(\d{1,3})\.(\d{1,3})$", line, re.I)
            if fs_match:
                my_net = int(fs_match.group(1))
                my_stn = int(fs_match.group(2))
            elif re.search("quit", line, re.I) == None:
                fsop_result, fsop_error, reply_packet = aun_client.FSOp(my_net, my_stn, 0x00, bytearray(line, "ascii"))
                error_string = aun_client.report_FSOp_result(aun_client, fsop_result, fsop_error, reply_packet)
                if fsop_error != 0:
                    return fsop_error, line, error_string
        else:
            aun_client.debug("Exiting")

    return 0, 0, None

def dummy_callback(net, stn, port, ctrl, ptype, seq, content):
    print (f'Callback: Traffic to port {port:02X}, ctrl {ctrl:02X}, seq {seq:08X} from {net}.{stn}, {content}')

def user_thread(aun_client, server = "1.254", username = "", password = ""):

    my_net, my_stn = select_server(server)

    if my_net == None:
        return None 

    if login(my_net, my_stn, username, password) == False:
        return None
    
    cmd = ""

    while (re.search("^\s*quit\s*$", cmd, re.I) == None and re.search("^\s*bye\s*$", cmd, re.I) == None):
        print("> *", end="")
        cmd = input()
        fs_match = re.search("^FS\s+(\d{1,3})\.(\d{1,3})$", cmd, re.I)
        if fs_match:
            my_net = int(fs_match.group(1))
            my_stn = int(fs_match.group(2))
        elif re.search("quit", cmd, re.I) == None:
            fsop_result, fsop_error, reply_packet = aun_client.FSOp(my_net, my_stn, 0x00, bytearray(cmd, "ascii"))
            if fsop_error != 0:
                error_string = aun_client.report_FSOp_result(aun_client, fsop_result, fsop_error, reply_packet)
                print (f"Error &{fsop_error:02X} - {error_string}")
            else:
                fsop_string = aun_client.report_FSOp_result(aun_client, fsop_result, fsop_error, reply_packet)
                print (f"{fsop_string}")


        else:
            print("Exiting")

argumentList = sys.argv[1:]
long_options = ["help", "server=", "user=", "password=", "localport=", "bindaddr=", "pipebase=", "timeout=", "script-params=", "script=", "debug", "traffic-debug", "aunmap=", "hostmap="]

server = "1.254"
username = ""
password = ""
local_port = 32768
bind_addr = ''
timeout = 1.5
script = None
debug = False
traffic_debug = False
script_params = [ ] 
pipebase = None
aunmap = None
hostmap = None

arguments, values = getopt.getopt(argumentList, "", long_options)
for currentArgument, currentValue in arguments:
    if currentArgument == "help":
        print ("pycoclient:\n")
        print ("  --aunmap=/path      : Path to aunmap file. Defaults to ~/.aunmap")
        print ("  --bindaddr=<ip>     : Set address to bind local UDP socket to")
        print ("  --debug             : Enable non-traffic debug")
        print ("  --hostmap=/path    : Path to hosts map file. Defaults to ~/.hostsmap")
        print ("  --localport=<n>     : Set local AUN port number (default: 32768)")
        print ("  --password=password : Set password for login command")
        print ("  --pipebase=/path    : Use Econet HPB pipe connector not AUN over IP, base pipe path as specified")
        print ("  --script=<file>     : Execute *-commands from <file> and then quit")
        print ("  --script-params=\"x,x,x,x\": Parameters to substitute for %n in scripts")
        print ("  --server=net.stn    : Default to this station to send FS Operations to (default: 1.254)")
        print ("  --timeout=<s>       : Timeout for AUN replies in seconds (can be float)")
        print ("  --traffic-debug     : Enable traffic debug")
        print ("  --user=username     : Set username for login command")
        exit(0)
    elif currentArgument == "--aunmap":
        aunmap = currentValue
    elif currentArgument == "--bindaddr":
        bind_addr = currentValue
    elif currentArgument == "--debug":
        debug = True
    elif currentArgument == "--hostmap":
        hostmap = currentValue
    elif currentArgument == "--localport":
        local_port = int(currentValue)
    elif currentArgument == "--password":
        password = currentValue
    elif currentArgument == "--pipebase":
        pipebase = currentValue
    elif currentArgument == "--script":
        script = currentValue
    elif currentArgument == "--script-params":
        script_params = currentValue.split(",")
    elif currentArgument == "--server":
        server = currentValue
    elif currentArgument == "--timeout":
        timeout = float(currentValue)
    elif currentArgument == "--traffic-debug":
        traffic_debug = True
    elif currentArgument == "--user":
        username = currentValue

# Create an AUN client

aun_client = AUNProtocol.AUNClient(localport = local_port, bind_addr = bind_addr, timeout = timeout, debug_on = debug, traffic_debug_on = traffic_debug, pipebase = pipebase, aunmap_file = aunmap, hostmap_file = hostmap)

if aun_client == None:
	print ("Unable to create listener")
	exit(0)

if script:
    result, line, error = execute_script(aun_client, script)

    if result != 0:
        print (f"Error &{result:02X} at {line} - {error}")
        exit(result)
    else:
        exit(0)

else:
    # The AUNClient will have started a listener thread
    front_thread = threading.Thread(target=user_thread, args=(aun_client, server, username, password))
    front_thread.start()
    front_thread.join()
